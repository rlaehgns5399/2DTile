# 2DTile

도형이 주어질 때, 도형이 어떤 타일에 속하는지 구함

## 문제 예시

왼쪽 밑 부터 `0`번 타일이라고 가정하면 다음과 같다.

`(x, y)`는 타일의 왼쪽 밑의 좌표 값이다.

<pre>
2(0,1)	3(1,1)
0(0,0)	1(1,0)
</pre>

![image](https://user-images.githubusercontent.com/26527826/48421740-6e882580-e7a0-11e8-816b-f76e8e1f7cbd.png)

주어진 도형은 다음과 같다.

![image](https://user-images.githubusercontent.com/26527826/48423325-bc525d00-e7a3-11e8-8c60-b0ac9d5390d9.png)

`레벨 0` 타일 에서는, 도형이 1번 타일을 덮으므로, **`lv0-1-0`**(1번 타일)을 리턴한다. (레벨 0타일, x: 1, y: 1)

그러나 나머지가 존재하므로, 0과 3번 타일을 각각 4타일씩 나눈다. 그리고 타일의 레벨은 1 증가한다.

![image](https://user-images.githubusercontent.com/26527826/48423332-c07e7a80-e7a3-11e8-82dc-e63ede80af63.png)

이제, 우리는 0, 3번 타일에 각각 4타일 씩, 총 8타일을 조사한다.

이것을 x, y 좌표, 타일 번호를 매기면 다음과 같다.

<pre>
22(0,1.5)	23(0.5,1.5)	32(1,1.5)	33(1.5,1.5)
20(0,1)		21(0.5,1)	30(1,1)		31(1.5,1)
02(0,0.5)	03(0.5,0.5)	12(1,0.5)	13(1.5,0.5)
00(0,0)		01(0.5,0)	10(1,0) 	11(1.5,0)
</pre>

도형이 01번 타일(x: 0.5, y: 0), 31번 타일(x: 1.5, y: 1)을 덮으므로, **`(lv1-0.5-0)`, `(lv1-1.5-1)`**을 리턴한다.

역시나 나머지가 존재하므로, 30번 타일(x: 1, y: 1)을 4타일로 나눈다.

![image](https://user-images.githubusercontent.com/26527826/48423341-c4aa9800-e7a3-11e8-97ce-694cb7004491.png)

30번 타일(x: 1, y: 1)은 다음과 같이 된다. (나머지 타일들은 생략)

<pre>
302(1,1.25)	303(1.25,1.25)
300(1,1)	301(1.25,1)
</pre>

도형이 301번 타일(x: 1.25, y: 1)을 덮으므로, **`lv2-1.25-1`**을 리턴한다.

마침내 우리는 도형을 덮는 모든 타일들을 찾아냈다. 따라서 알고리즘을 종료한다.

<hr>

## 문제 정의

`레벨 0` 타일은 총 50개의 타일(0\~9, 0\~4)이 존재한다. 또한 레벨은 **15**까지 있다.

레벨이 증가함에 따라, 각 타일은 4개의 작은 타일들로 분할할 수 있다.

(레벨 1의 총 타일 수는 레벨 0타일의 4배, 50*4 = 200개)

그리고 점의 집합이나 리스트가 주어지면, 그것은 도형으로 만들 수 있다.

또한 `레벨 0`에서, 도형이 `레벨 0` 타일의 어떤 것이라도 정확히 포함하면, 어딘가에 그 정보를 저장하고 나머지에 대해 계산한다.

만약 도형이 불완전하게 `레벨 0`타일을 덮는다면, 레벨 1을 증가시키고, 그 타일은 4 타일로 분할된다.

그리고 도형이 타일을 다 덮을 때까지 비교하고 진행한다.

저장할 정보는 타일의 x, y 좌표, 그리고 레벨이다(**`LVn-x-y`**)

### 어떤 타일이 도형을 덮는지 어떻게 계산할 것인지?

제한된 범위의 직선의 방정식과 그의 교점을 통해 계산할 것이다.

(2018. 12. 03) 타일은 네 꼭지점으로 이루어져 있다.

<pre>
P3(x, y+n)		P4(x+n, y+n)
P1(x, y)		P2(x+n, y)
</pre>

특정 타일이 도형 안에 있는지 판별하는 것은, 이 네개의 점이 도형 안에 있는지 검사하면 된다.

이 방법은 `Ray Casting`을 사용하여 검출한다.

하지만 특정 모양에서는 이 방법에 문제가 있는데, 도형의 변과, 타일의 네 꼭지점으로 이루어진 선분끼리 교점이 있는지 비교한다.

대략적인 알고리즘은 다음과 같다.

<pre>
*(레벨 0)*
while(레벨 0의 모든 타일에 대해)
	if(레벨 0 타일의 4 꼭지점이 도형 안에 있지만,
	4 꼭지점으로 이루어진 선분들이 도형 변에 하나라도 겹쳐진다면)
		타일을 4분할 하고, 레벨을 1 증가시키며, 큐에 넣는다.
	else if(위의 if문에 걸리지 않고 타일의 4 꼭지점에 도형 안에 있다면)
		해당 타일을 결과 리스트에 추가한다.
	else if(네 점으로 이루어진 선분이 하나라도 도형의 변에 걸친다면)
		타일을 4분할 하고, 레벨을 1 증가시키며, 큐에 넣는다.
	// else가 없음에 주의하라

*(레벨 1이상)*
while(큐에 아이템이 있을 때)
	타일 = 큐에서 아이템 하나를 빼낸다.
	
	if(현재 타일의 레벨이 16이상이면) 
		continue
	타일의 네 꼭지점을 구한다.
	
	if(현재 타일의 4 꼭지점이 도형 안에 있지만,
	4 꼭지점으로 이루어진 선분들이 도형 변에 하나라도 겹쳐진다면)
		타일을 4분할 하고, 레벨을 1 증가시키며, 큐에 넣는다.
	else if(위의 if문에 걸리지 않고 타일의 4 꼭지점에 도형 안에 있다면)
		해당 타일을 결과 리스트에 추가한다.
	else if(네 점으로 이루어진 선분이 하나라도 도형의 변에 걸친다면)
		타일을 4분할 하고, 레벨을 1 증가시키며, 큐에 넣는다.
	// else가 없음에 주의하라
	
</pre>

여기서 볼 수 있듯이, `레벨 0`에서는, `brute force`방식을 통해, 50개의 타일을 모두 검사한다.
	
그리고 나눌 타일에 대해서만 연산이 진행된다.


## 참고

- [Flood Fill](https://ko.wikipedia.org/wiki/%ED%94%8C%EB%9F%AC%EB%93%9C_%ED%95%84) (이 문제에 대해선 딱히 좋은 방법은 아닌 것 같음)
- [QuadTree](https://en.wikipedia.org/wiki/Quadtree) (이 아이디어를 이용하긴 했음)
- [Ray casting algorithm(Detect point in polygon)](https://en.wikipedia.org/wiki/Point_in_polygon)
- [Convex hull](https://en.wikipedia.org/wiki/Convex_hull_algorithms) (도형을 만들 때, 이 방법을 통하면 넓이를 최대화한 도형을 얻을 수 있음)

# QuadtreeUI

![image](https://user-images.githubusercontent.com/26527826/48673764-30b44400-eb88-11e8-8f62-f33f422e71a8.png)

완벽하지 않은 쿼드트리의 예시(버전 1)

![image](https://user-images.githubusercontent.com/26527826/48693180-fbf1cc80-ec1b-11e8-9f93-ee299d3e8a7e.gif)

쿼드트리를 수정했으나, 좀 더 수정할 것이 남아 있다.

![image](https://user-images.githubusercontent.com/26527826/48844184-76694a80-eddc-11e8-82f7-f1ae6cf0fd3f.png)

분홍색 타일의 경우, 점 네개는 도형에 포함되어 있지만 초록색 타일로 인식되면 안된다.

그것을 [이 곳](http://bowbowbow.tistory.com/17)를 통해 에러를 고쳤다. 

이전에는, 분홍색 타일이 초록색 타일로 인식되었었다.

하지만 현재는 아니다.(2018. 11. 21)

![honeycam 2018-11-23 20-41-37](https://user-images.githubusercontent.com/26527826/48941807-5cf10b80-ef60-11e8-9019-d8b7c5bdbf1f.gif)

내가 생각하기에 드디어 이 일을 끝낸 것 같다(2018. 11. 23).

너가 볼 수 있듯이, 각각 타일은 레벨에 따라 다른 색깔로 표시된다.

15레벨까지 표현되는 것을 원했으나, 내 컴퓨터에서 11레벨만 넘어가도 컴퓨터가 도형을 표현하는데 상당히 느려진다.

또한, 쿼드트리를 구현했지만 그 코드 자체는 필요가 없었다(물론 이 아이디어 자체는 좋았고, 참고할만 했음).

도형을 만드는데, 나는 `컨벡스 헐`을 쓰지 않았다.

만약에 너가 이것을 사용하기 원한다면, `Point` 클래스 코드를 수정하여 점들의 집합을 재구성하면 된다.

<hr>

# XDOErrorDectectorUI

![Something](https://user-images.githubusercontent.com/26527826/48317753-20591200-e63a-11e8-891f-295913eb85b9.png)

이 프로그램이 엄청 간단합니다.

맨 위 레이블은 제가 입력한 디렉토리를 나타냅니다.(조금 잘렸네요)

만약 이 디렉토리를 바꾸고 싶다면, `postgreSQL.cs` 파일로 가서 14번 째 줄을 수정하세요.

```
public String baseURL = @"C:\Users\KimDoHoon\Desktop\C++_Project\data";
```

또한 반드시 postgreSQL의 db 정보를 수정하여야 합니다.

`postgreSQL.cs`에서, 157~164째 줄을 수정하세요.

```
    class DB
    {
        public String Host = "localhost";
        public String Username = "postgres";
        public String Password = "root";
        public String Database = "mydata";
        public String Table = "xdo";
    }
```

DB에서 xdo 테이블의 구조는 다음과 같습니다.

![image](https://user-images.githubusercontent.com/26527826/48317831-5d71d400-e63b-11e8-92c2-858debe25d8a.png)

**Update** 버튼은 다음과 같은 기능을 합니다:

- 주어진 디렉터리에서 `.xdo` 파일을 찾습니다.
- `.xdo` 파일을 파싱하고, 텍스쳐 파일(.jpg)을 검사합니다.
```
성공: 텍스쳐 파일이 잘 있습니다.
오류: 텍스쳐 파일이 없습니다.
경고: 텍스쳐 파일은 있지만, 파일 이름의 대소문자가 다릅니다.
```
- DB에서 `xdo` 테이블의 아이템 전부를 삭제합니다. 
- `xdo` 테이블에 파싱한 결과를 나타냅니다.


**Check** 버튼은 다음과 같은 기능을 합니다:

![image](https://user-images.githubusercontent.com/26527826/48317770-6f06ac00-e63a-11e8-86d5-e9791191b4ba.png)

- DB를 읽고, 행들을 얻어옵니다.
- 밑 레이블을 행의 갯수로 나타냅니다.
- 리스트 뷰를 채웁니다.


